---
title: "Relatório de coautoria"
runtime: shiny
output:
  html_document:
    code_folding: hide
    css: style.css
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = FALSE,
  warning = FALSE,
  message = FALSE,
  fig.cap = '',
  fig.align = 'center',
  fig.width = 10,
  fig.height = 8
)
```

```{r echo = FALSE, warning=FALSE, message=FALSE}
library(networkD3)
library(tidyverse)
library(shiny)
library(hrbrthemes)
theme_set(theme_minimal())
source(here::here('reports/scripts/prepare_coautorias_data.R'))

env <- "dev"
path <- ''

if (env == "dev") {
  path = "reports/coautorias-por-prop/"
} 

# Lendo documentos e autores de ambas as casas para processar as coautorias
documentos_camara <- 
  agoradigital::read_current_docs_camara("/home/jair/Documents/leggoR/data/camara/documentos.csv") %>% 
  mutate(data = as.Date(format(status_proposicao_data_hora, "%Y-%m-%d")))
documentos_senado <- agoradigital::read_current_docs_senado("/home/jair/Documents/leggoR/data/senado/documentos.csv")
autores_camara <- agoradigital::read_current_autores_camara("/home/jair/Documents/leggoR/data/camara/autores.csv")
autores_senado <- agoradigital::read_current_autores_senado("/home/jair/Documents/leggoR/data/senado/autores.csv")

# Gerando dado de autorias de documentos para ambas as casas
autorias_camara <- prepare_autorias_df_camara(documentos_camara, autores_camara)
autorias_senado <- prepare_autorias_df_senado(documentos_senado, autores_senado)

peso_autorias_docs_camara <- compute_peso_autoria_doc(autorias_camara)
peso_autorias_docs_senado <- compute_peso_autoria_doc(autorias_senado)

parlamentares_camara <- autores_camara %>% dplyr::select(id_autor, nome, partido, uf)
parlamentares_senado <- autores_senado %>% dplyr::select(id_autor, nome = nome_autor, partido, uf)

senadores <- agoradigital::read_senadores('/home/jair/Documents/leggoR/data/senado/parlamentares.csv')
props <- 
  read_csv('/home/jair/Documents/leggoR/data/proposicoes.csv') %>% 
  mutate(nome_formal = paste0(apelido, "- ", sigla_tipo, " ", numero, "/", format(data_apresentacao, "%Y"), " - ", casa)) %>% 
  select(id_principal = id_ext, nome_formal) %>% 
  mutate(id_principal = as.character(id_principal))

coautorias_camara <- get_coautorias(peso_autorias_docs_camara, autorias_camara, parlamentares_camara)
coautorias_senado <- get_coautorias(peso_autorias_docs_senado, autorias_senado, parlamentares_senado)

coautorias <- 
  rbind(coautorias_camara, coautorias_senado) %>% left_join(props, by = "id_principal") %>% 
  filter(nome.x != nome.y) %>% 
  mutate(partido.x = if_else(is.na(partido.x), "", partido.x),
         partido.y = if_else(is.na(partido.y), "", partido.y))

props <- props %>% 
  filter(id_principal %in% coautorias$id_principal)

```


### As proposições

Para geração deste relatório foram utilizadas as proposições da plataforma [Leggo](https://leggo.org.br), considerando só a Câmara. Para cada uma das proposições, existe uma série de outras proposições relacionadas, como emendas, pareceres, requerimentos, etc., que também foram consideradas para a criação dos grupos parlamentares. 

<br>

### A detecção dos grupos

A detecção de grupos é feita da seguinte forma: inicialmente se combinam em pares os autores de todas as proposições respectivas relacionadas. Isso quer dizer que, para uma proposição do tipo requerimento que foi feito por 3 autores, x, y e z, serão criados 3 pares: um contendo x e y, um com x e z e outro com y e z. Desta forma, cada um dos deputados autores de uma proposição terá uma relação com todos os outros coautores. 

<br>

#### Tabela de pares

A tabela abaixo lista todos os pares e respectivas relações, calculadas de acordo com o peso explicado abaixo. 
```{r echo=FALSE}
DT::DTOutput("dt")
```

<br>

#### Peso das relações 

A fim de deixar os grupos mais refinados e precisamos, optamos por adicionar uma penalidade que varia de acordo com o número de pessoas envolvidas: quanto mais coautores em uma proposição, menos precisas estarão as relações entre os deputados e por isso terão pesos menores; de forma análoga, uma proposição que possua apenas dois coautores, terá o peso da relação máximo e estarão muito mais próximos.

Transformamos este peso de relações em um parâmetro, entre 0.1 e 1, que é usado para a geração dos grupos: quanto maior o seu valor, mais forte serão as relações entre os deputados e, consequentemente, os grupos gerados. A partir deste peso, filtramos todas as relações que possuem valor maior ou igual a ele e executamos a criação dos grupos. 

<br>

```{r echo=FALSE, warning=FALSE, fig.width = 8, fig.height = 6}
#plotOutput("hist")
```

#### Rede de grupos

Tendo os pares e o peso de suas relações, os grupos foram feitos utilizando uma técnica chamada `agrupamento`, que agrupa os dados de forma automática com base na similaridade entre eles. **Para o peso mínimo de 0.01 das relações**.

<br>

##### Grafo Geral:
Este são todos os agrupamentos da proposição.

```{r echo=FALSE, fig.width = 4, fig.height = 4}
choices_ids <- 
  props %>% 
  select(nome_formal) %>%
  as.list() 

choices_ids <- choices_ids$nome_formal

selectInput("nome_formal", "Nome Formal",
             choices_ids,
            selected = choices_ids[1])

sliderInput("date",
                  "Dates:",
                  min = as.Date("2016-01-01","%Y-%m-%d"),
                  max = as.Date(Sys.Date(),"%Y-%m-%d"),
                  value = c(as.Date("1999-01-01","%Y-%m-%d"), as.Date(Sys.Date(),"%Y-%m-%d")),
                  timeFormat="%Y-%m-%d")

observe({
  if (!is.null(input$nome_formal)) {
    coautorias_filtrado <-
      coautorias %>%
      filter(!is.na(data.x)) %>% 
      filter(nome_formal == input$nome_formal) %>%
      arrange(data.x)

    min_date <-
      coautorias_filtrado %>%
      head(1) %>%
      purrr::pluck("data.x")

    max_date <-
      coautorias_filtrado %>%
      tail(1) %>%
      purrr::pluck("data.x")
    
    if (min_date == max_date) {
      max_date = max_date + 1
    }
    
    updateSliderInput(
      session, "date",
      min= as.Date(min_date, "%Y-%m-%d"),
      max=as.Date(max_date,"%Y-%m-%d"), 
      value=c(as.Date("2017-01-16", "%Y-%m-%d"), as.Date(max_date,"%Y-%m-%d")))

  }
})

br()

forceNetworkOutput("grafo")
```

Observando a rede acima, não dá pra saber quais são os partidos predominantes, então veremos a distribuição partidária deste grupo no histograma abaixo:

```{r echo=FALSE, fig.width = 4, fig.height = 3}
#plotOutput("hist_grafo")
```


```{r echo=FALSE, fig.width = 4, fig.height = 4}
# forceNetworkOutput("grafo_grupo2")
```

```{r echo=FALSE}

generate_graph_by_group <- function(df, id_group) {
  nodes <- df[[1]] %>%
  filter(group == id_group)

  return(list(nodes, df[[2]]))
}

generate_graph <- function(nodes, edges) {
    print(nodes)
  print(edges)
  fn <- forceNetwork(
    Links = edges, 
    Nodes = nodes,
    Source = "source", 
    Target = "target",
    Value = "value", 
    NodeID = "nome_eleitoral",
    Group ="partido", 
    zoom = T,
    linkColour = "#bfbdbd",
    fontFamily = "roboto",
    fontSize = 16,
    opacity = 0.8)
  
  return(fn)


}

getCoautorias <- reactive({
  nodes_edges <- 
    generate_nodes_and_edges(
      coautorias %>% 
      filter(data.x >= input$date[[1]] & data.x < input$date[[2]]) %>% 
      filter(nome_formal == input$nome_formal)) 
  return(nodes_edges)
})

```

```{r echo=FALSE, context="server"}
getPesosProp <- function(nome_formal) {
  coautorias %>% 
    filter(nome_formal == nome_formal) %>% 
    select(peso_arestas) %>% 
    as.list() %>% 
    purrr::pluck("peso_arestas")
}

output$hist <- renderPlot({
  if(nrow(coautorias) > 0) {
    coautorias_hist <- 
      coautorias %>%
      filter(nome_formal == input$nome_formal) %>% 
      filter(data.x >= input$date[[1]] & data.x < input$date[[2]])
    
    if(nrow(coautorias_hist) != 0) {
      coautorias_hist %>% 
        ggplot(aes(x = peso_arestas)) +
        geom_histogram(boundary = 0, fill = "#1BB5A9", color = "#10726B") +
        scale_x_continuous(limits = c(0, max(coautorias$peso_arestas) + 0.1), 
                           breaks = seq(0, max(coautorias$peso_arestas) + 0.1, 1)) +
        labs(x = "Peso das relações", y = "Número de relações") +
        theme_ipsum_rc()
    }
  }
})

output$dt <- 
  DT::renderDataTable(
    coautorias %>% 
      select(id_principal, nome.x, nome.y, peso_arestas, num_coautorias, nome_formal, data.x) %>% 
      distinct() %>% 
      filter(nome_formal == input$nome_formal) %>% 
      filter(data.x >= input$date[[1]] & data.x < input$date[[2]]) %>% 
      rename(peso_relacao = peso_arestas, 
             nome_deputado_a = nome.x,
             nome_deputado_b = nome.y,
             coautorias_conjuntas = num_coautorias) %>% 
      arrange(desc(peso_relacao)), 
    options = list(pageLength = 10,
                   scrollX = TRUE)
    )
  
output$grafo <- 
  networkD3::renderForceNetwork({
      Sys.sleep(2)
      graph <- getCoautorias()
      print(length(graph))
    if(nrow(graph[[1]]) > 0 & nrow(graph[[2]]) > 0) {
      generate_graph(graph[[1]], graph[[2]])
    } else {
      NA
    }
  })

output$hist_grafo <- renderPlot({ 
  nodes <-getCoautorias()[[1]]
  if(nrow(nodes) > 0) {
    nodes <- nodes %>%
      group_by(partido) %>% 
      count() 
    
    nodes %>% 
    ggplot(aes(x = reorder(partido, n), y = n)) +
      geom_bar(fill = "#1BB5A9", color="#10726B", stat="identity") +
      coord_flip() +
      labs(x = "Partido", y = "Número de deputados") +
      scale_y_continuous(breaks = seq(0, max(nodes$n), 1)) +
      theme_ipsum_rc()
  }
})

# output$grafo_grupo2 <-
#     networkD3::renderForceNetwork({
#     graph <- getCoautorias()
#     graph[[1]] <- 
#       graph[[1]] %>%
#       filter(group == 2)
# 
#     if(nrow(graph[[1]]) > 0 & nrow(graph[[2]]) > 0) {
#       generate_graph(graph[[1]], graph[[2]])
#     }
# })
```
